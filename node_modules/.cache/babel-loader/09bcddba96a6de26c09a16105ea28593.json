{"ast":null,"code":"import { window, document } from 'ssr-window';\nimport $ from 'dom7';\nimport Support from '../../utils/support';\nimport Device from '../../utils/device';\n\nfunction initTouch() {\n  var app = this;\n  var params = app.params.touch;\n  var useRipple = params[\"\".concat(app.theme, \"TouchRipple\")];\n\n  if (Device.ios && Device.webView) {\n    // Strange hack required for iOS 8 webview to work on inputs\n    window.addEventListener('touchstart', function () {});\n  }\n\n  var touchStartX;\n  var touchStartY;\n  var touchStartTime;\n  var targetElement;\n  var trackClick;\n  var activeSelection;\n  var scrollParent;\n  var lastClickTime;\n  var isMoved;\n  var tapHoldFired;\n  var tapHoldTimeout;\n  var preventClick;\n  var activableElement;\n  var activeTimeout;\n  var needsFastClick;\n  var needsFastClickTimeOut;\n  var rippleWave;\n  var rippleTarget;\n  var rippleTimeout;\n\n  function findActivableElement(el) {\n    var target = $(el);\n    var parents = target.parents(params.activeStateElements);\n    var activable;\n\n    if (target.is(params.activeStateElements)) {\n      activable = target;\n    }\n\n    if (parents.length > 0) {\n      activable = activable ? activable.add(parents) : parents;\n    }\n\n    return activable || target;\n  }\n\n  function isInsideScrollableViewLight(el) {\n    var pageContent = el.parents('.page-content');\n    return pageContent.length > 0;\n  }\n\n  function isInsideScrollableView(el) {\n    var pageContent = el.parents('.page-content');\n\n    if (pageContent.length === 0) {\n      return false;\n    } // This event handler covers the \"tap to stop scrolling\".\n\n\n    if (pageContent.prop('scrollHandlerSet') !== 'yes') {\n      pageContent.on('scroll', function () {\n        clearTimeout(activeTimeout);\n        clearTimeout(rippleTimeout);\n      });\n      pageContent.prop('scrollHandlerSet', 'yes');\n    }\n\n    return true;\n  }\n\n  function addActive() {\n    if (!activableElement) return;\n    activableElement.addClass('active-state');\n  }\n\n  function removeActive() {\n    if (!activableElement) return;\n    activableElement.removeClass('active-state');\n    activableElement = null;\n  }\n\n  function isFormElement(el) {\n    var nodes = 'input select textarea label'.split(' ');\n    if (el.nodeName && nodes.indexOf(el.nodeName.toLowerCase()) >= 0) return true;\n    return false;\n  }\n\n  function androidNeedsBlur(el) {\n    var noBlur = 'button input textarea select'.split(' ');\n\n    if (document.activeElement && el !== document.activeElement && document.activeElement !== document.body) {\n      if (noBlur.indexOf(el.nodeName.toLowerCase()) >= 0) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function targetNeedsFastClick(el) {\n    /*\n    if (\n      Device.ios\n      &&\n      (\n        Device.osVersion.split('.')[0] > 9\n        ||\n        (Device.osVersion.split('.')[0] * 1 === 9 && Device.osVersion.split('.')[1] >= 1)\n      )\n    ) {\n      return false;\n    }\n    */\n    var $el = $(el);\n    if (el.nodeName.toLowerCase() === 'input' && (el.type === 'file' || el.type === 'range')) return false;\n    if (el.nodeName.toLowerCase() === 'select' && Device.android) return false;\n    if ($el.hasClass('no-fastclick') || $el.parents('.no-fastclick').length > 0) return false;\n    if (params.fastClicksExclude && $el.closest(params.fastClicksExclude).length > 0) return false;\n    return true;\n  }\n\n  function targetNeedsFocus(el) {\n    if (document.activeElement === el) {\n      return false;\n    }\n\n    var tag = el.nodeName.toLowerCase();\n    var skipInputs = 'button checkbox file image radio submit'.split(' ');\n    if (el.disabled || el.readOnly) return false;\n    if (tag === 'textarea') return true;\n\n    if (tag === 'select') {\n      if (Device.android) return false;\n      return true;\n    }\n\n    if (tag === 'input' && skipInputs.indexOf(el.type) < 0) return true;\n    return false;\n  }\n\n  function targetNeedsPrevent(el) {\n    var $el = $(el);\n    var prevent = true;\n\n    if ($el.is('label') || $el.parents('label').length > 0) {\n      if (Device.android) {\n        prevent = false;\n      } else if (Device.ios && $el.is('input')) {\n        prevent = true;\n      } else prevent = false;\n    }\n\n    return prevent;\n  } // Ripple handlers\n\n\n  function findRippleElement(el) {\n    var rippleElements = params.touchRippleElements;\n    var $el = $(el);\n\n    if ($el.is(rippleElements)) {\n      if ($el.hasClass('no-ripple')) {\n        return false;\n      }\n\n      return $el;\n    }\n\n    if ($el.parents(rippleElements).length > 0) {\n      var rippleParent = $el.parents(rippleElements).eq(0);\n\n      if (rippleParent.hasClass('no-ripple')) {\n        return false;\n      }\n\n      return rippleParent;\n    }\n\n    return false;\n  }\n\n  function createRipple($el, x, y) {\n    if (!$el) return;\n    rippleWave = app.touchRipple.create($el, x, y);\n  }\n\n  function removeRipple() {\n    if (!rippleWave) return;\n    rippleWave.remove();\n    rippleWave = undefined;\n    rippleTarget = undefined;\n  }\n\n  function rippleTouchStart(el) {\n    rippleTarget = findRippleElement(el);\n\n    if (!rippleTarget || rippleTarget.length === 0) {\n      rippleTarget = undefined;\n      return;\n    }\n\n    var inScrollable = params.fastClicks ? isInsideScrollableView(rippleTarget) : isInsideScrollableViewLight(rippleTarget);\n\n    if (!inScrollable) {\n      createRipple(rippleTarget, touchStartX, touchStartY);\n    } else {\n      rippleTimeout = setTimeout(function () {\n        createRipple(rippleTarget, touchStartX, touchStartY);\n      }, 80);\n    }\n  }\n\n  function rippleTouchMove() {\n    clearTimeout(rippleTimeout);\n    removeRipple();\n  }\n\n  function rippleTouchEnd() {\n    if (rippleWave) {\n      removeRipple();\n    } else if (rippleTarget && !isMoved) {\n      clearTimeout(rippleTimeout);\n      createRipple(rippleTarget, touchStartX, touchStartY);\n      setTimeout(removeRipple, 0);\n    } else {\n      removeRipple();\n    }\n  } // Mouse Handlers\n\n\n  function handleMouseDown(e) {\n    findActivableElement(e.target).addClass('active-state');\n\n    if ('which' in e && e.which === 3) {\n      setTimeout(function () {\n        $('.active-state').removeClass('active-state');\n      }, 0);\n    }\n\n    if (useRipple) {\n      touchStartX = e.pageX;\n      touchStartY = e.pageY;\n      rippleTouchStart(e.target, e.pageX, e.pageY);\n    }\n  }\n\n  function handleMouseMove() {\n    $('.active-state').removeClass('active-state');\n\n    if (useRipple) {\n      rippleTouchMove();\n    }\n  }\n\n  function handleMouseUp() {\n    $('.active-state').removeClass('active-state');\n\n    if (useRipple) {\n      rippleTouchEnd();\n    }\n  } // Send Click\n\n\n  function sendClick(e) {\n    var touch = e.changedTouches[0];\n    var evt = document.createEvent('MouseEvents');\n    var eventType = 'click';\n\n    if (Device.android && targetElement.nodeName.toLowerCase() === 'select') {\n      eventType = 'mousedown';\n    }\n\n    evt.initMouseEvent(eventType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n    evt.forwardedTouchEvent = true;\n\n    if (app.device.ios && window.navigator.standalone) {\n      // Fix the issue happens in iOS home screen apps where the wrong element is selected during a momentum scroll.\n      // Upon tapping, we give the scrolling time to stop, then we grab the element based where the user tapped.\n      setTimeout(function () {\n        targetElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n        targetElement.dispatchEvent(evt);\n      }, 10);\n    } else {\n      targetElement.dispatchEvent(evt);\n    }\n  } // Touch Handlers\n\n\n  function handleTouchStart(e) {\n    var _this = this;\n\n    isMoved = false;\n    tapHoldFired = false;\n\n    if (e.targetTouches.length > 1) {\n      if (activableElement) removeActive();\n      return true;\n    }\n\n    if (e.touches.length > 1 && activableElement) {\n      removeActive();\n    }\n\n    if (params.tapHold) {\n      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);\n      tapHoldTimeout = setTimeout(function () {\n        if (e && e.touches && e.touches.length > 1) return;\n        tapHoldFired = true;\n        e.preventDefault();\n        $(e.target).trigger('taphold');\n      }, params.tapHoldDelay);\n    }\n\n    if (needsFastClickTimeOut) clearTimeout(needsFastClickTimeOut);\n    needsFastClick = targetNeedsFastClick(e.target);\n\n    if (!needsFastClick) {\n      trackClick = false;\n      return true;\n    }\n\n    if (Device.ios || Device.android && 'getSelection' in window) {\n      var selection = window.getSelection();\n\n      if (selection.rangeCount && selection.focusNode !== document.body && (!selection.isCollapsed || document.activeElement === selection.focusNode)) {\n        activeSelection = true;\n        return true;\n      }\n\n      activeSelection = false;\n    }\n\n    if (Device.android) {\n      if (androidNeedsBlur(e.target)) {\n        document.activeElement.blur();\n      }\n    }\n\n    trackClick = true;\n    targetElement = e.target;\n    touchStartTime = new Date().getTime();\n    touchStartX = e.targetTouches[0].pageX;\n    touchStartY = e.targetTouches[0].pageY; // Detect scroll parent\n\n    if (Device.ios) {\n      scrollParent = undefined;\n      $(targetElement).parents().each(function () {\n        var parent = _this;\n\n        if (parent.scrollHeight > parent.offsetHeight && !scrollParent) {\n          scrollParent = parent;\n          scrollParent.f7ScrollTop = scrollParent.scrollTop;\n        }\n      });\n    }\n\n    if (touchStartTime - lastClickTime < params.fastClicksDelayBetweenClicks) {\n      e.preventDefault();\n    }\n\n    if (params.activeState) {\n      activableElement = findActivableElement(targetElement);\n      activeTimeout = setTimeout(addActive, 0);\n    }\n\n    if (useRipple) {\n      rippleTouchStart(targetElement, touchStartX, touchStartY);\n    }\n\n    return true;\n  }\n\n  function handleTouchMove(e) {\n    if (!trackClick) return;\n    var distance = params.fastClicksDistanceThreshold;\n\n    if (distance) {\n      var pageX = e.targetTouches[0].pageX;\n      var pageY = e.targetTouches[0].pageY;\n\n      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {\n        isMoved = true;\n      }\n    } else {\n      isMoved = true;\n    }\n\n    if (isMoved) {\n      trackClick = false;\n      targetElement = null;\n      isMoved = true;\n\n      if (params.tapHold) {\n        clearTimeout(tapHoldTimeout);\n      }\n\n      if (params.activeState) {\n        clearTimeout(activeTimeout);\n        removeActive();\n      }\n\n      if (useRipple) {\n        rippleTouchMove();\n      }\n    }\n  }\n\n  function handleTouchEnd(e) {\n    clearTimeout(activeTimeout);\n    clearTimeout(tapHoldTimeout);\n    var touchEndTime = new Date().getTime();\n\n    if (!trackClick) {\n      if (!activeSelection && needsFastClick) {\n        if (!(Device.android && !e.cancelable) && e.cancelable) {\n          e.preventDefault();\n        }\n      }\n\n      if (params.activeState) removeActive();\n\n      if (useRipple) {\n        rippleTouchEnd();\n      }\n\n      return true;\n    }\n\n    if (document.activeElement === e.target) {\n      if (params.activeState) removeActive();\n\n      if (useRipple) {\n        rippleTouchEnd();\n      }\n\n      return true;\n    }\n\n    if (!activeSelection) {\n      e.preventDefault();\n    }\n\n    if (touchEndTime - lastClickTime < params.fastClicksDelayBetweenClicks) {\n      setTimeout(removeActive, 0);\n\n      if (useRipple) {\n        rippleTouchEnd();\n      }\n\n      return true;\n    }\n\n    lastClickTime = touchEndTime;\n    trackClick = false;\n\n    if (Device.ios && scrollParent) {\n      if (scrollParent.scrollTop !== scrollParent.f7ScrollTop) {\n        return false;\n      }\n    } // Add active-state here because, in a very fast tap, the timeout didn't\n    // have the chance to execute. Removing active-state in a timeout gives\n    // the chance to the animation execute.\n\n\n    if (params.activeState) {\n      addActive();\n      setTimeout(removeActive, 0);\n    } // Remove Ripple\n\n\n    if (useRipple) {\n      rippleTouchEnd();\n    } // Trigger focus when required\n\n\n    if (targetNeedsFocus(targetElement)) {\n      if (Device.ios && Device.webView) {\n        targetElement.focus();\n        return false;\n      }\n\n      targetElement.focus();\n    } // Blur active elements\n\n\n    if (document.activeElement && targetElement !== document.activeElement && document.activeElement !== document.body && targetElement.nodeName.toLowerCase() !== 'label') {\n      document.activeElement.blur();\n    } // Send click\n\n\n    e.preventDefault();\n\n    if (params.tapHoldPreventClicks && tapHoldFired) {\n      return false;\n    }\n\n    sendClick(e);\n    return false;\n  }\n\n  function handleTouchCancel() {\n    trackClick = false;\n    targetElement = null; // Remove Active State\n\n    clearTimeout(activeTimeout);\n    clearTimeout(tapHoldTimeout);\n\n    if (params.activeState) {\n      removeActive();\n    } // Remove Ripple\n\n\n    if (useRipple) {\n      rippleTouchEnd();\n    }\n  }\n\n  function handleClick(e) {\n    var allowClick = false;\n\n    if (trackClick) {\n      targetElement = null;\n      trackClick = false;\n      return true;\n    }\n\n    if (e.target.type === 'submit' && e.detail === 0 || e.target.type === 'file') {\n      return true;\n    }\n\n    if (!targetElement) {\n      if (!isFormElement(e.target)) {\n        allowClick = true;\n      }\n    }\n\n    if (!needsFastClick) {\n      allowClick = true;\n    }\n\n    if (document.activeElement === targetElement) {\n      allowClick = true;\n    }\n\n    if (e.forwardedTouchEvent) {\n      allowClick = true;\n    }\n\n    if (!e.cancelable) {\n      allowClick = true;\n    }\n\n    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {\n      allowClick = false;\n    }\n\n    if (!allowClick) {\n      e.stopImmediatePropagation();\n      e.stopPropagation();\n\n      if (targetElement) {\n        if (targetNeedsPrevent(targetElement) || isMoved) {\n          e.preventDefault();\n        }\n      } else {\n        e.preventDefault();\n      }\n\n      targetElement = null;\n    }\n\n    needsFastClickTimeOut = setTimeout(function () {\n      needsFastClick = false;\n    }, Device.ios || Device.androidChrome ? 100 : 400);\n\n    if (params.tapHold) {\n      tapHoldTimeout = setTimeout(function () {\n        tapHoldFired = false;\n      }, Device.ios || Device.androidChrome ? 100 : 400);\n    }\n\n    return allowClick;\n  }\n\n  function handleTouchStartLight(e) {\n    isMoved = false;\n    tapHoldFired = false;\n    preventClick = false;\n\n    if (e.targetTouches.length > 1) {\n      if (activableElement) removeActive();\n      return true;\n    }\n\n    if (e.touches.length > 1 && activableElement) {\n      removeActive();\n    }\n\n    if (params.tapHold) {\n      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);\n      tapHoldTimeout = setTimeout(function () {\n        if (e && e.touches && e.touches.length > 1) return;\n        tapHoldFired = true;\n        e.preventDefault();\n        preventClick = true;\n        $(e.target).trigger('taphold');\n      }, params.tapHoldDelay);\n    }\n\n    targetElement = e.target;\n    touchStartX = e.targetTouches[0].pageX;\n    touchStartY = e.targetTouches[0].pageY;\n\n    if (params.activeState) {\n      activableElement = findActivableElement(targetElement);\n\n      if (!isInsideScrollableViewLight(activableElement)) {\n        addActive();\n      } else {\n        activeTimeout = setTimeout(addActive, 80);\n      }\n    }\n\n    if (useRipple) {\n      rippleTouchStart(targetElement, touchStartX, touchStartY);\n    }\n\n    return true;\n  }\n\n  function handleTouchMoveLight(e) {\n    var distance = params.fastClicks ? params.fastClicksDistanceThreshold : 0;\n\n    if (distance) {\n      var pageX = e.targetTouches[0].pageX;\n      var pageY = e.targetTouches[0].pageY;\n\n      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {\n        isMoved = true;\n      }\n    } else {\n      isMoved = true;\n    }\n\n    if (isMoved) {\n      preventClick = true;\n\n      if (params.tapHold) {\n        clearTimeout(tapHoldTimeout);\n      }\n\n      if (params.activeState) {\n        clearTimeout(activeTimeout);\n        removeActive();\n      }\n\n      if (useRipple) {\n        rippleTouchMove();\n      }\n    }\n  }\n\n  function handleTouchEndLight(e) {\n    clearTimeout(activeTimeout);\n    clearTimeout(tapHoldTimeout);\n\n    if (document.activeElement === e.target) {\n      if (params.activeState) removeActive();\n\n      if (useRipple) {\n        rippleTouchEnd();\n      }\n\n      return true;\n    }\n\n    if (params.activeState) {\n      addActive();\n      setTimeout(removeActive, 0);\n    }\n\n    if (useRipple) {\n      rippleTouchEnd();\n    }\n\n    if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {\n      if (e.cancelable) e.preventDefault();\n      preventClick = true;\n      return false;\n    }\n\n    return true;\n  }\n\n  function handleClickLight(e) {\n    var localPreventClick = preventClick;\n\n    if (targetElement && e.target !== targetElement) {\n      localPreventClick = true;\n    }\n\n    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {\n      localPreventClick = true;\n    }\n\n    if (localPreventClick) {\n      e.stopImmediatePropagation();\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    if (params.tapHold) {\n      tapHoldTimeout = setTimeout(function () {\n        tapHoldFired = false;\n      }, Device.ios || Device.androidChrome ? 100 : 400);\n    }\n\n    preventClick = false;\n    targetElement = null;\n    return !localPreventClick;\n  }\n\n  function emitAppTouchEvent(name, e) {\n    app.emit({\n      events: name,\n      data: [e]\n    });\n  }\n\n  function appClick(e) {\n    emitAppTouchEvent('click', e);\n  }\n\n  function appTouchStartActive(e) {\n    emitAppTouchEvent('touchstart touchstart:active', e);\n  }\n\n  function appTouchMoveActive(e) {\n    emitAppTouchEvent('touchmove touchmove:active', e);\n  }\n\n  function appTouchEndActive(e) {\n    emitAppTouchEvent('touchend touchend:active', e);\n  }\n\n  function appTouchStartPassive(e) {\n    emitAppTouchEvent('touchstart:passive', e);\n  }\n\n  function appTouchMovePassive(e) {\n    emitAppTouchEvent('touchmove:passive', e);\n  }\n\n  function appTouchEndPassive(e) {\n    emitAppTouchEvent('touchend:passive', e);\n  }\n\n  var passiveListener = Support.passiveListener ? {\n    passive: true\n  } : false;\n  var activeListener = Support.passiveListener ? {\n    passive: false\n  } : false;\n  document.addEventListener('click', appClick, true);\n\n  if (Support.passiveListener) {\n    document.addEventListener(app.touchEvents.start, appTouchStartActive, activeListener);\n    document.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);\n    document.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);\n    document.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListener);\n    document.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);\n    document.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);\n  } else {\n    document.addEventListener(app.touchEvents.start, function (e) {\n      appTouchStartActive(e);\n      appTouchStartPassive(e);\n    }, false);\n    document.addEventListener(app.touchEvents.move, function (e) {\n      appTouchMoveActive(e);\n      appTouchMovePassive(e);\n    }, false);\n    document.addEventListener(app.touchEvents.end, function (e) {\n      appTouchEndActive(e);\n      appTouchEndPassive(e);\n    }, false);\n  }\n\n  if (Support.touch) {\n    if (params.fastClicks) {\n      app.on('click', handleClick);\n      app.on('touchstart', handleTouchStart);\n      app.on('touchmove', handleTouchMove);\n      app.on('touchend', handleTouchEnd);\n    } else {\n      app.on('click', handleClickLight);\n      app.on('touchstart', handleTouchStartLight);\n      app.on('touchmove', handleTouchMoveLight);\n      app.on('touchend', handleTouchEndLight);\n    }\n\n    document.addEventListener('touchcancel', handleTouchCancel, {\n      passive: true\n    });\n  } else if (params.activeState) {\n    app.on('touchstart', handleMouseDown);\n    app.on('touchmove', handleMouseMove);\n    app.on('touchend', handleMouseUp);\n  }\n\n  document.addEventListener('contextmenu', function (e) {\n    if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {\n      e.preventDefault();\n    }\n\n    if (useRipple) {\n      if (activableElement) removeActive();\n      rippleTouchEnd();\n    }\n  });\n}\n\nexport default {\n  name: 'touch',\n  params: {\n    touch: {\n      // Fast clicks\n      fastClicks: false,\n      fastClicksDistanceThreshold: 10,\n      fastClicksDelayBetweenClicks: 50,\n      fastClicksExclude: '',\n      // CSS selector\n      // ContextMenu\n      disableContextMenu: false,\n      // Tap Hold\n      tapHold: false,\n      tapHoldDelay: 750,\n      tapHoldPreventClicks: true,\n      // Active State\n      activeState: true,\n      activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item',\n      mdTouchRipple: true,\n      iosTouchRipple: false,\n      touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content'\n    }\n  },\n  instance: {\n    touchEvents: {\n      start: Support.touch ? 'touchstart' : 'mousedown',\n      move: Support.touch ? 'touchmove' : 'mousemove',\n      end: Support.touch ? 'touchend' : 'mouseup'\n    }\n  },\n  on: {\n    init: initTouch\n  }\n};","map":null,"metadata":{},"sourceType":"module"}